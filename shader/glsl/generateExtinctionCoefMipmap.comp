#version 430

// 设置精度
precision highp float;
precision highp int;
precision highp sampler3D;
precision highp image3D;

layout(binding=0)uniform sampler3D TexInputVolume;
layout(binding=1,rgba8)uniform image3D TexOutputVolume;
layout(binding=2)uniform DicomUniformBufferObject{
    vec3 voxelSize;
    vec3 voxelResolution;
    vec3 boxSize;
    vec3 realSize;//! 忘记更新了，导致窗宽窗位完全错误
    float windowCenter;
    float windowWidth;
    float minVal;
    float alphaCorrection;// 作为透明度的矫正系数
    float stepLength;
    float glow;
    int steps;
}dicomUbo;
layout( push_constant ) uniform GenGaussianMMPushConstants
{
    float currentLevel;
} pushConstants;

// 假设每个工作组的大小为8x8x8
layout(local_size_x=4,local_size_y=4,local_size_z=4)in;

#define USE_HIGH_RESOLUTION
// #define USE_INTENSITY

#ifdef USE_HIGH_RESOLUTION
vec3 curResolution=vec3(512.,512.,512.);
#else
vec3 curResolution= dicomUbo.voxelResolution;
#endif

// 对原始像素值的高低8位进行高斯滤波，并存储高低8位
// 缺点：滤波有效性待评估
// 优点：窗宽窗位的调整有效
vec4 GaussianFilter(uvec3 globalIdx){
    vec4 sumOfColor=vec4(0.f);
    float sumOfWeight=0.f;
    
    // Compute the current Gaussian filter from [-vtk, vtk]
    // int vtk=3*int(pow(2.0,pushConstants.currentLevel-1.));
    int vtk=3;
    float sigma=pow(2.0,pushConstants.currentLevel);// 层级sigma，高低分辨率下的mip效果均很差
    // float sigma=1.; // 保持sigma不变，高低分辨率下的mip效果均很好
    for(int ptx=-vtk;ptx<=vtk;ptx++){
        for(int pty=-vtk;pty<=vtk;pty++){
            for(int ptz=-vtk;ptz<=vtk;ptz++){
                // https://en.wikipedia.org/wiki/Gaussian_filter
                // Get interpolated samples maintaining the defined standard deviation
                float fx=float(ptx)*sigma;
                float fy=float(pty)*sigma;
                float fz=float(ptz)*sigma;
                // 计算当前位置的高斯权重
                float weight=(sigma*sigma*sigma)*exp(-(fx*fx+fy*fy+fz*fz)/(2.*sigma*sigma));
                // 计算采样位置，采样位置为当前全局索引除以3D纹理的尺寸，以保证采样坐标在[0, 1]的范围内
                float posScale = pow(2.0, pushConstants.currentLevel);
                vec3 samplePos=((vec3(globalIdx)+vec3(.5))*posScale + vec3(fx,fy,fz))/curResolution;
                // 采样当前位置的颜色值
                // vec4 color=textureLod(TexInputVolume,samplePos,pushConstants.currentLevel-1.);// 存储原始像素值的高八位和第八位,这样会对边界进行平滑,从而在计算intensity后截断,使得边界更加清晰
                vec4 color = texture(TexInputVolume, samplePos);
                
                // 计算当前位置的高斯权重与颜色值的乘积
                sumOfColor+=weight*color;
                
                // 计算当前位置的高斯权重之和
                sumOfWeight+=weight;
            }
        }
    }
    
    return sumOfColor/sumOfWeight;
}

// 只对intensity进行高斯滤波，并存储intensity
// 缺点：窗宽窗位的调整会失效
// 优点：具有数学依据
vec4 GaussianFilterIntensity(uvec3 globalIdx){
    float sumOfIntensity=0.f;
    float sumOfWeight=0.f;
    
    // Compute the current Gaussian filter from [-vtk, vtk]
    // int vtk=3*int(pow(2.0,pushConstants.currentLevel-1.));
    int vtk=3;
    float sigma=pow(2.0,pushConstants.currentLevel);// 层级sigma
    // float sigma=1.; // 保持sigma不变
    for(int ptx=-vtk;ptx<=vtk;ptx++){
        for(int pty=-vtk;pty<=vtk;pty++){
            for(int ptz=-vtk;ptz<=vtk;ptz++){
                // https://en.wikipedia.org/wiki/Gaussian_filter
                // Get interpolated samples maintaining the defined standard deviation
                float fx=float(ptx)*sigma;
                float fy=float(pty)*sigma;
                float fz=float(ptz)*sigma;
                // 计算当前位置的高斯权重
                float weight=(sigma*sigma*sigma)*exp(-(fx*fx+fy*fy+fz*fz)/(2.*sigma*sigma));
                // 计算采样位置，采样位置为当前全局索引除以3D纹理的尺寸，以保证采样坐标在[0, 1]的范围内
                float posScale = pow(2.0, pushConstants.currentLevel);
                vec3 samplePos=((vec3(globalIdx)+vec3(.5))*posScale + vec3(fx,fy,fz))/curResolution;
                // 采样当前位置的intensity值
                // vec4 sampleColor=textureLod(TexInputVolume,samplePos,pushConstants.currentLevel-1.);
                vec4 sampleColor=texture(TexInputVolume,samplePos);
                float intensity=sampleColor.r;
                intensity=clamp(intensity,0.,1.);
                
                // 计算当前位置的高斯权重与颜色值的乘积
                sumOfIntensity+=weight*intensity;
                
                // 计算当前位置的高斯权重之和
                sumOfWeight+=weight;
            }
        }
    }
    
    float resIntensity=clamp(sumOfIntensity/sumOfWeight,0.,1.);
    return vec4(resIntensity);
}

void main(){
    // 获取当前工作组的全局索引
    ivec3 globalIdx=ivec3(gl_GlobalInvocationID.xyz);// 计算着色器在3D图像中的位置
    
    // if(globalIdx.x>dicomUbo.voxelResolution.x-1
        //     ||globalIdx.y>dicomUbo.voxelResolution.y-1
    // ||globalIdx.z>dicomUbo.voxelResolution.z-1)
    // return;
    
    // 采样位置为当前全局索引除以3D纹理的尺寸，以保证采样坐标在[0, 1]的范围内
    // !需要加上.5 否则会出现锯齿
    float curMipLevel = 1.0;    
    // vec3 samplePos=(vec3(globalIdx)*3.+vec3(.5))/dicomUbo.voxelResolution; // 这里用于测试，证明已经修改了3D纹理的mipLevel 1
    vec3 samplePos=(vec3(globalIdx)*pow(2.0,curMipLevel)+vec3(.5))/dicomUbo.voxelResolution;
    float intensity=textureLod(TexInputVolume,samplePos,0.).r;

    
    // 将颜色值写入输出的3D图像
    // imageStore(TexOutputVolume,ivec3(globalIdx),vec4(intensity,0.,0.,0.));// 直接存储intensity
    // imageStore(TexOutputVolume,ivec3(globalIdx),texture(TexInputVolume,samplePos));// 直接存储高低8位

    #ifdef USE_INTENSITY
    imageStore(TexOutputVolume,ivec3(globalIdx),vec4(GaussianFilterIntensity(globalIdx).r,0.,0.,0.));// 高斯滤波，存储intensity
    #else
    imageStore(TexOutputVolume,ivec3(globalIdx),vec4(GaussianFilter(globalIdx).rgb,1.));// 高斯滤波，存储高低8位
    #endif

    // test 用来测试pushConstants是否有效
    // imageStore(TexOutputVolume,ivec3(globalIdx),vec4(pushConstants.currentLevel/10.,pushConstants.currentLevel/10.,pushConstants.currentLevel/10.,1.));
    
}